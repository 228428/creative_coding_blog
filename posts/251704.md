---
title: Week Six
published_at: 2025-04-07
snippet: What I learnt in week 6
disable_html_sanitization: true
allow_math: true
---

# Week 6 Session 1

## Reflection

This week’s session focused on signals and envelopes, and how they’re used in creative coding. We learned that envelopes can work with both milliseconds and seconds, but using seconds feels more intuitive — it’s easier to think in seconds than in tiny units like milliseconds. That small shift made a big difference in how I understood timing and movement in projects.

We also looked into phase, which moves between 0 and 1. But to use that in a creative way, you usually need to map it — basically transforming that 0 to 1 range into something else that suits your project. Whether it’s controlling position, speed, or even visual effects, mapping lets you reshape simple values into more complex behaviors. It’s like making your own rules for how something behaves.

Another thing we explored was using power curves like p\*\*3. This creates more dramatic, curved motion. For example, the higher you raise the power, the sharper or more sudden the movement or effect becomes. I started to understand how you could shape time-based behavior visually, like easing animations in and out in a stylized way.

One moment that really stood out to me was when Thomas showed us his glitchy teapot. I thought it was amazing — the way it broke apart, but still had structure. It honestly looked like digital sculpture. I had been struggling with trying to glitch my own teapot, so seeing his version helped me understand how far you could push things and how important randomness, noise, and distortion can be in generative art. It was a huge “aha” moment.

We also spent some time reading through code together as a class. At first, it felt overwhelming, but then — kind of oddly — I started to understand it. Like, lines of code that would’ve looked like gibberish to me before suddenly made sense. I’m still not perfect at it, but it felt like a real shift. Slowly but surely, it’s starting to click.

## HomeWork

From my research, I learnt:

### q5.js

#### What it’s for:

q5.js is a lightweight JavaScript library for creative coding, similar to p5.js but more minimal.

It’s made for fast and playful sketching using the HTML5 canvas, perfect for drawing, animation, and simple interaction.

#### Best for:

Quick visual experiments

Generative art

Interactive sketches

### c2.js

#### What it’s for:

c2.js is focused on generative art and geometric design, especially using recursion and 2D logic.

It gives you tools to create visuals through math-based systems and patterns.

#### Best for:

Algorithmic visuals (e.g. spirals, symmetry, fractals)

Geometry-driven art

Clean, rule-based design work

### svg.js

#### What it’s for:

svg.js is for working with SVG (Scalable Vector Graphics) in the browser.

It lets you create, manipulate, and animate vector shapes easily using JavaScript.

#### Best for:

Vector graphics like icons or logos

Animations in web interfaces

Clean visuals that scale without losing quality

| Library    | Output Type      | Focus Area                          | Use Case Example                            |
| ---------- | ---------------- | ----------------------------------- | ------------------------------------------- |
| **q5.js**  | HTML5 Canvas     | Creative coding & animation         | Drawing shapes, interactive sketches        |
| **c2.js**  | HTML5 Canvas     | Generative systems, geometric rules | Recursive patterns, algorithmic visuals     |
| **svg.js** | SVG (vector DOM) | Scalable graphics & animations      | Animating icons, building web illustrations |

### Can we use these libraries from within a javascript module? Explain why / why not.

According to my research, yes, we can use these libraries inside a JavaScript module, but it depends on how the library was written. Some libraries, like svg.js, are already available as ES modules, so we can import them directly using import statements, which works well in a modern JavaScript setup.

However, others like q5.js or c2.js might not be set up as modules by default. In those cases, we’d need to include them using a `<script>` tag in the HTML, or try to find a module-compatible version. It’s not always super smooth.

So overall, it’s possible, but not always simple—especially if the library wasn’t designed for modules in the first place.

### In what situations might a tool like esm.sh be useful?

According to my research, esm.sh is helpful when you're working with JavaScript modules and want to use libraries that weren’t originally written as ES modules. Sometimes, older libraries use different formats (like CommonJS), which don’t work well with the modern import system unless you use a build tool like Webpack or Vite. But with esm.sh, it converts those libraries into ES modules automatically, so you can import them directly using a URL—no need to install anything or set up complex tools. I think it’s especially useful if you’re just working on a small project, testing something quickly, or coding directly in the browser using `<script type="module">`.

### Use one of these libraries on your blog to demonstrate how to use a signal or envelope to make something change over time.

<iframe src="signal.html" width="600" height="400"></iframe>
